<html>
        <head>
        <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
        <link href='https://fonts.googleapis.com/css?family=Hind' rel='stylesheet'>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
        <link rel="stylesheet" type="text/css" href="css/main.css">
        </head>
        <body>
        <div class="logo">
          <img src="img/main_logo.svg" alt="">
        </div>
        <div class="text">
          <h1>PORTO<br>BLOCKCHAIN<br>CONFERENCE</h1>
          <p>Porto.BC is for anyone who wants to learn more<br>about Blockchain technology for new projects or their jobs.</p>
        </div>
        <img id="move" src="img/cube.svg" alt="">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r121/three.min.js"></script>
        <script>
        var three = THREE;

    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(60, window.innerWidth/ window.innerHeight ,0.5, 1000);
    camera.position.z = 5;

    var renderer = new THREE.WebGLRenderer({ alpha: true });
    renderer.setSize(window.innerWidth , window.innerHeight);
    renderer.setPixelRatio( window.devicePixelRatio );
    document.body.appendChild(renderer.domElement);

    //Cube
    var geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
    var material = new THREE.MeshLambertMaterial({color: 0x00aaff});
    var light = new THREE.DirectionalLight( 0xffffff, 1.5 );
    light.position.set( 0,0.0 ,1).normalize();
    scene.add(light);

    var cube = new THREE.Mesh(geometry, material);
    scene.add(cube);

/* */
var isDragging = false;
var previousMousePosition = {
x: 0,
y: 0
};
$(renderer.domElement).on('mousedown', function(e) {
isDragging = true;
})
.on('mousemove', function(e) {
var deltaMove = {
  x: e.offsetX - previousMousePosition.x,
  y: e.offsetY - previousMousePosition.y
};

if (isDragging) {

  var deltaRotationQuaternion = new three.Quaternion()
    .setFromEuler(new three.Euler(
      toRadians(deltaMove.y * 1),
      toRadians(deltaMove.x * 1),
      0,
      'XYZ'
    ));

  cube.quaternion.multiplyQuaternions(deltaRotationQuaternion, cube.quaternion);
}

previousMousePosition = {
  x: e.offsetX,
  y: e.offsetY
};
});
/* */

$(document).on('mouseup', function(e) {
isDragging = false;
});



// shim layer with setTimeout fallback
window.requestAnimFrame = (function() {
return window.requestAnimationFrame ||
window.webkitRequestAnimationFrame ||
window.mozRequestAnimationFrame ||
function(callback) {
  window.setTimeout(callback, 1000 / 60);
};
})();

var lastFrameTime = new Date().getTime() / 1000;
var totalGameTime = 0;

function update(dt, t) {

cube.rotation.y += 1 * dt;

setTimeout(function() {
var currTime = new Date().getTime() / 1000;
var dt = currTime - (lastFrameTime || currTime);
totalGameTime += dt;

update(dt, totalGameTime);

lastFrameTime = currTime;
}, 0);
}

function animate(){
      requestAnimationFrame(animate);

update(0, totalGameTime);
      renderer.render(scene, camera);
    }
animate();


function toRadians(angle) {
return angle * (Math.PI / 180);
}

function toDegrees(angle) {
return angle * (180 / Math.PI);
}

//animacoes cubos background
const $cube = $("#move")
let x = 0
let y=0
let directionx = 1
let directiony = 1
const interval = setInterval(() => {
  x = x + 1 * directionx
  y = y + 1 * directiony

  $cube.css({ transform: `translate(${x}vw,${y}vh)` })

  if (x >= window.innerWidth / 10 || x < 0) directionx = directionx * -1
  if (y >= 15|| y < -100) directiony = directiony * -1
  }, 100)

          </script>
        </body>
</html>
